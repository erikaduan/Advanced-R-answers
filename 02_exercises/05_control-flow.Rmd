---
title: "Chapter 5: Control flow"
author: "Erika Duan"
date: "`r Sys.Date()`"
output: 
  github_document:
    toc: true
---  

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide')
```

```{r, message = FALSE, warning = FALSE}
#-----load R libraries-----   
if (!require(pacman)) install.packages("pacman")
p_load(tidyverse)  
```


# Chapter goals    

Understanding what **control flow** is helps you to:  

+ To understand how to manage code control flow using two different types of tools - choices and loops.    
+ To understand how `if` statements and `switch()` calls operate in R.    
+ To understand how `for` loops and `while` loops operate in R.     


# Choices    

## Using `if` statements  

Choices comprise `if` statements and `switch()` calls and these tools alter code flow by allowing you to run different code depending on the input.  

The basic form of an `if` statement is:  

+ `if (condition) {true_action}`    
+ `if (condition) {true_action} else {false_action}`    

In the first form, if the condition is `TRUE`, `true_action` is evaluated.   
In the second form, if the condition is `TRUE`, `true_action` is evaluated and if the condition is `FALSE`, `false_action` is evaluated.       

In reality, choices are usually compound `ifelse` statements containing multiple conditions. 

```{r}
#-----coding best practice for writing compound if statements-----  
student_grade <- function(score) {
  if (score >= 90) {
    "A"
  } else if (score >= 80) {
    "B"
  } else if (score >= 50) {
    "C"
  } else {
    "F"
  }
}

grades <- c(92, 45, 75, 80)  

vapply(grades, student_grade, FUN.VALUE = "chr") 
#> [1] "A" "F" "C" "B"  
```

**Note:** An excellent tutorial on the differences between `apply()`, `lapply()` and `sapply()` can be found [here](https://www.guru99.com/r-apply-sapply-tapply.html). A great explanation of `vapply` usage can also be found [here](https://stackoverflow.com/questions/51657605/fun-value-argument-in-vapply).        

Since an `if` statement returns a value, its result can be assigned. However, assignment is only recommended if the `if` statement fits on a single line, to maintain readability.     

```{r}
#-----you can assign the ouput of single line if statements-----  
# the global evaluation of if (TRUE) is always TRUE   

if (TRUE) {print(1)}
#> [1] 1

if (TRUE) print(1)  
#> [1] 1 

# {print(1)} and print(1) and 1 return the same output  

x1 <- if (TRUE) print("eval TRUE") else print("eval FALSE")     
x2 <- if (FALSE) print("eval FALSE") else print("eval TRUE")     

c(x1, x2)    
#> [1] "eval TRUE" "eval TRUE"      
```

When you evaluate a single `if` statement that does not contain an `else` condition, your `if` statement invisibly returns `NULL` if the condition is `FALSE`. As functions like `c()` and `paste()` invisibly drop `NULL` inputs, this allows for compact outputs.       

```{r}
#-----c() and paste() invisibly drops NULL inputs-----   
c("id1", NULL, "id3", NULL, "id5")     
#> [1] "id1" "id3" "id5"              

paste0("Hello ", NULL, "world", NULL, "!")    
#> [1] "Hello world!"      
```

```{r}
#-----compact outputs generated by single if arguments----- 
greet_person <- function(person, birthday = FALSE) {
  paste0(
    "Hi ", person,
    if (birthday == TRUE) " and HAPPY BIRTHDAY!"  
  )
}   

greet_person("Erika", birthday = FALSE)
#> [1] "Hi Erika"     

greet_person("Dan", birthday = TRUE)   
#> [1] "Hi Dan and HAPPY BIRTHDAY!"     
```


### Handling invalid inputs to `if` statements      

Since an `if` statement should always evaluate to a single `TRUE` or `FALSE` (a single logical type), most other inputs will generate an error.     

```{r}
#-----invalid inputs to if statements-----  
if (TRUE) print(1)     
#> [1] 1      

if (1) {print(1)}  
#> [1] 1  

# if (x) {print(1)}
#> Error: object 'x' not found

x <- 5
if (x) {print(1)}
#> [1] 1  

# if("x") {print(1)}  
#> Error in if ("x") { : argument is not interpretable as logical   
```

An exception occurs when a logical vector of length greater than 1 is the output. In R, the first element of the logical vector is then used alongside a warning message. It is recommmended to prevent this, as you might accidentally miss this warning, by setting the environment variable `Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")`.            

```{r, warning = FALSE}   
#-----be careful of length(logical vector) > 1 outputs-----   
if (c(TRUE, FALSE, TRUE)) print(1)
#> ## Warning in if (c(TRUE, FALSE, TRUE)) print(1): the condition has length > 1    
#> ## and only the first element will be used    
#> [1] 1    
```

```{r}
#-----recommended practice to prevent length(logical vector) > 1 output evaluation-----
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")  

# if (c(TRUE, FALSE, TRUE)) print(1)
#> Error in if (c(TRUE, FALSE, TRUE)) print(1) : 
#>   the condition has length > 1
```  


### Handling a vector of logical values as an input        

When your input is a vector of logical values i.e. when you are systematically evaluating a conditon on elements within a vector, `ifelse()` or `case_when` can be used to handle the input. The function `ifelse()` is a vectorised function containing `test`, `yes` and `no` vectors which can be recycled to the same length.   

From R documentation on `iselse(test, yes, no)`:  

> ifelse returns a value with the same shape as test which is filled with elements selected from either yes or no depending on whether the element of test is TRUE or FALSE.     

```{r}
#-----ifelse() handles a vector of logical values-----  
x <- 1:6

ifelse(x %% 3 == 0, "divisible", as.character(x))
#> [1] "1"         "2"         "divisible" "4"         "5"         "divisible"  

# yes vector output and no vector output are both character type    
```

**Note:** `ifelse()` usage is only recommended for scenarios when the `yes` and `no` vectors are the same type, as it can be hard to predict the output type of complex conditions.      

The function `case_when` uses a special syntax to allow any number of condition-vector pairs i.e. the function is not limited to just outputting `yes` and `no` vectors.    

```{r}
#-----case_when() handles a vector of logical values-----  
y <- 1:6  

case_when(
  y %% 6 == 0 ~ "div by 6",
  y %% 4 == 0 ~ "div by 4", 
  y %% 3 == 0 ~ "div by 3",
  TRUE ~ as.character(y)
)  
#> [1] "1"        "2"        "div by 3" "div by 4" "5"        "div by 6"   

# case_when() conditions follow a hierarchy where the first TRUE condition is outputted         
```


## Using `switch()` calls    

The function `switch()` can be used as an alternative to `ifelse()` as it evaluates an expression and accordingly chooses one of the further arguments. Using `switch()` instead of `ifelse()` can improve the readability of compound `ifelse` statements.       

```{r}
#-----using ifelse() to write compound statements-----   
clean_x <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2"
  } else if (x == "c") {
    "option 3"  
  } else {
    stop("Invalid x value")   
  }
}  

clean_x("a")
#> [1] "option 1"  

# clean_x("d")
#> Error in clean_x("d") : Invalid x value
```

```{r}
#-----using switch() to write compound statements-----     
cleaner_x <- function(x) {
  switch (x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid x value")
  )
}

cleaner_x("a")
#> [1] "option 1"  

# cleaner_x("d")   
#> Error in cleaner_x("d") : Invalid x value   
```

**Note:** The last component of `switch()` should always throw an error i.e. force `stop()` and print an error message. Otherwise, unmatched inputs from `switch()` will invisibly return `NULL`.  

```{r}
#-----when the last component of switch() does not throw an error message-----  
cleaner_x_e <- function(x) {
  switch (x,
          a = "option 1",
          b = "option 2",
          c = "option 3"
  )
}

cleaner_x_e("d")

# no output is created for unmatched inputs as NULL is returned invisibly  
# this is an undesirable behaviour  
```

When multiple inputs share the same output, `switch()` allows us to use a shorthand that mimics the behaviour of C's `switch` statement.  

```{r}
#-----when multiple inputs have the same output-----  
count_legs <- function(x) {
  switch (x,
          cow = ,
          horse = ,
          sheep = ,
          dog = 4 ,
          human = , 
          bird = , 
          stop("Unknown input entered")
  )
}

count_legs("cow")
#> [1] 4     

count_legs("dog")  
#> [1] 4     

# leaving the right hand side of = empty allows the input to fall through to the next value  
```


**Note:** The recommendation is to use `switch()` only when you have character inputs, as numeric inputs have unpredictable failure modes.    

```{r}
#-----exercise 5.2.4.1-----   

#-----exercise 5.2.4.2-----   

```


# Loops     
